quantile(c(1:200, NA), 0.1)
?quantile
chopit.pain$coef$beta0
dim(chopit.pain$coef$beta0)
?quantile
?seq
For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  average.x <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(col.var.name, average.x, var.names.values))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  average.x <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(var.name.col, average.x, var.names.values))#
}
For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(var.name.col, x.average, var.names.values))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(var.name.col, x.average, var.name.values))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
test.marginal < -ChopitMarginal(chopit.pain, "age", 2, 10)
test.marginal <- ChopitMarginal(chopit.pain, "age", 2, 10)
test.marginal[3]
length(test.marginal[3])
length(test.marginal[[3]])
test.marginal <- ChopitMarginal(chopit.pain, "age", 2, 11)
length(test.marginal[[3]])
test.marginal[3]
quantile(SHARE$age, probs = c(0.01,0.99), na.rm = TRUE)
?replicate
c(1,2)[c(1,2,1,2,1,1,1)]
seq()
seq(1,1, length.out = 10)
?seq
?replicate
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  values <- matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values))#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  #   Retrieving the right coefficients#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(var.name.col, x.average, var.name.values))#
}
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 2, 10)
?unlist
cbind(list(1:2,3:4))
matrix(list(1:2,3:4))
matrix(unlist(list(1:2,3:4)))
matrix(unlist(list(1:2,3:4)), nrow = 2)
?as.matrix
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  values <- as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE)#
  # Calculation of the through-y.star.s variable's marginal impact on probability of y.s >= response#
  #   Retrieving the right coefficients#
  beta <- c(0, chopit.results$coef$beta0)#
  return(list(var.name.col, x.average, var.name.values, values))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d77e0e025e")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d77e0e025e")
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d749bda9f9")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d749bda9f9")
ChopitMarginal(chopit.pain, "age", 2, 10)
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d742e24041")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d742e24041")
ChopitMarginal(chopit.pain, "age", 2, 10)
mean(SHARE$lnPChhincome, na.rm=TRUE)
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d713e88db5")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d713e88db5")
ChopitMarginal(chopit.pain, "age", 2, 10)
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # each row of values is a value of x on which marginal impact should be calculated. All the variables are equal to their average, except of #
  # variable var.name, which takes one value of var.name.values in each row#
  values <- t(as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE))#
  values[, var.name.col] <- var.name.values #
#
  # Retrieving the right coefficients#
  beta0 <- chopit.results$coef$beta0#
  beta <- c(0, chopit.results$coef$beta0)#
  gamma <- chopit.results$coef$gamma#
  kK <- chopit.results$constants$kK#
  x <- chopit.results$original.x$original.x.s#
#
  # Calculating the taus#
  tau0 <- as.matrix(x) %*% gamma[, 1, drop = FALSE]#
  if (kK >1) { #
    for (k in 2:(kK - 1)) tau0 <- cbind(tau0, tau0[, ncol(tau0), drop = FALSE] + exp(as.matrix(x) %*% #
    gamma[, k, drop = FALSE]))#
  }#
  tau <- cbind(-Inf, tau0, +Inf)#
  # Calculating the through-y.star.s variable's marginal impact on P(y.s >= response) for each row in values#
  return(list(var.name.col, x.average, var.name.values, values, tau))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # each row of values is a value of x on which marginal impact should be calculated. All the variables are equal to their average, except of #
  # variable var.name, which takes one value of var.name.values in each row#
  values <- t(as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE))#
  values[, var.name.col] <- var.name.values #
#
  # Retrieving the right coefficients#
  beta0 <- chopit.results$coef$beta0#
  beta <- c(0, chopit.results$coef$beta0)#
  gamma <- chopit.results$coef$gamma#
  kK <- chopit.results$constants$kK#
  x <- chopit.results$original.x$original.x.s#
#
  # Calculating the tau for each row of values#
  tau0 <- values %*% gamma[, 1, drop = FALSE]#
  if (kK >1) { #
    for (k in 2:(kK - 1)) tau0 <- cbind(tau0, tau0[, ncol(tau0), drop = FALSE] + exp(values %*% #
    gamma[, k, drop = FALSE]))#
  }#
  tau <- cbind(-Inf, tau0, +Inf)#
  # Calculating the through-y.star.s variable's marginal impact on P(y.s >= response) for each row in values#
  return(list(var.name.col, x.average, var.name.values, values, tau))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
gamma
chopit.pain$coef$gamma
ChopitMarginal(chopit.pain, "age", 2, 10)
88 * -0.004575972 - -0.004575972 *46
-0.075 - 0.11706204
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 2, 10)
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d78af7049")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//Rtmp2Kb9Vo/file7d78af7049")
ChopitMarginal(chopit.pain, "age", 2, 10)
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # each row of values is a value of x on which marginal impact should be calculated. All the variables are equal to their average, except of #
  # variable var.name, which takes one value of var.name.values in each row#
  values <- t(as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE))#
  values[, var.name.col] <- var.name.values #
#
  # Retrieving the right coefficients#
  beta0 <- chopit.results$coef$beta0#
  beta <- c(0, chopit.results$coef$beta0)#
  gamma <- chopit.results$coef$gamma#
  kK <- chopit.results$constants$kK#
#
  # Calculating the tau for each row of values#
  tau0 <- values %*% gamma[, 1, drop = FALSE]#
  if (kK >1) { #
    for (k in 2:(kK - 1)) tau0 <- cbind(tau0, tau0[, ncol(tau0), drop = FALSE] + exp(values %*% #
    gamma[, k, drop = FALSE]))#
  }#
  tau <- cbind(-Inf, tau0, +Inf)#
  # Calculating the through-y.star.s variable's marginal impact on P(y.s >= response) for each row in values#
  latent.partial.marginal <- beta[var.name.col] * dnorm(values %*% t(t(beta)) - tau[, response - 1])#
  return(list(var.name.col, x.average, var.name.values, values, tau, latent.partial.marginal))#
}
ChopitMarginal(chopit.pain, "age", 2, 10)
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the marginal effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's marginal effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the marginal probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # each row of values is a value of x on which marginal impact should be calculated. All the variables are equal to their average, except of #
  # variable var.name, which takes one value of var.name.values in each row#
  values <- t(as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE))#
  values[, var.name.col] <- var.name.values #
#
  # Retrieving the right coefficients#
  beta0 <- chopit.results$coef$beta0#
  beta <- c(0, chopit.results$coef$beta0)#
  gamma <- chopit.results$coef$gamma#
  kK <- chopit.results$constants$kK#
#
  # Calculating the tau for each row of values#
  tau0 <- values %*% gamma[, 1, drop = FALSE]#
  if (kK >1) { #
    for (k in 2:(kK - 1)) tau0 <- cbind(tau0, tau0[, ncol(tau0), drop = FALSE] + exp(values %*% #
    gamma[, k, drop = FALSE]))#
  }#
  # Calculating the through-y.star.s variable's marginal impact on P(y.s >= response) for each row in values#
  latent.partial.marginal <- beta[var.name.col] * dnorm(values %*% t(t(beta)) - tau0[, response - 1])#
  return(list(var.name.col, x.average, var.name.values, values, tau, latent.partial.marginal))#
}
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 2, 10)
chopit.pain$coef
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 2, 10)
ChopitMarginal(chopit.pain, "age", 3, 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 3, 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 3, 10)
summary(chopit.pain)
c(2,3) * c(10,20)
NOTA BENE: en l'état, ne fonctionne qu'avec les variables continues.#
# TODO: intégrer une gestion des variables discrètes#
#
# For a given variable var.name, and a given k in 2, ..., K:#
#   - calculates the partial effect of this variable w.r.t. probability P(y.s >= response / bar.x_{- var.name}, x_{var.name}), for kNPoints values #
#     of x_{var.name} equally space points on spanning from the first percentile of this variable to its last percentile#
#   - calculates the subpart of this variable's partial effect that is related to its impact on y.s, on the same set of values#
#   - calculates the subpart of this variable's partial effect that is related to its impact on the taus, on the same set of values.#
ChopitMarginal <- function(chopit.results, var.name, response, kNPoints) {#
  # Args#
  #   chopit.results: object of class "Chopit". The x.tau and x.s should be the same for the marginal effects to be calculated.#
  #   var.name: name of the variable for which marginal impacts should be calculated#
  #   response: marginal effects are calculated on P(y.s >= response / x). Should be between 2 (proba equal to 1 if response = 1) and the highest#
  #             response category#
  #   kNPoints: number of points on which the marginal effects are going to be calculated#
  ##
  # Sanity Check#
  if (!class(chopit.results) == "Chopit") cat("ChopitMarginal: argument chopit.results is not of class 'Chopit' \n")#
  if (!is.character(var.name)) stop("ChopitMarginal: var.name is not of type character")#
  if (!(var.name %in% colnames(chopit.results$original.x$original.x.s))) stop("ChopitMarginal: var.name does not belong to the regressor names")#
  if (!all(chopit.results$original.x$original.x.tau == chopit.results$original.x$original.x.s, na.rm = TRUE)) stop("ChopitMarginal: in#
     chopit.results, x.tau != x.s")#
  if (response < 2) stop("ChopitMarginal: response smaller than 2")   #
  if (response > chopit.results$constants$kK) stop("ChopitMarginal: response biggher than kK from chopit.results")#
  # Locating the column of var.name#
  var.name.col <- match(var.name, colnames(chopit.results$original.x$original.x.s))#
  # Calculating the average values of all the regressors, including the intercept.#
  x.average <- colMeans(chopit.results$original.x$original.x.s, na.rm = TRUE)#
  # Calculating the set of values on which the partial probabilities are going to be calculated#
  var.name.quantiles <- quantile(chopit.results$original.x$original.x.s[, var.name.col], probs = c(0.01, 0.99), na.rm = TRUE)#
  var.name.values <- seq(from = var.name.quantiles[1], to = var.name.quantiles[2], length.out = kNPoints)#
  # each row of values is a value of x on which partial impact should be calculated. All the variables are equal to their average, except of #
  # variable var.name, which takes one value of var.name.values in each row#
  values <- t(as.matrix(unlist(replicate(length(var.name.values), x.average)), nrow = length(var.name.values), byrow = TRUE))#
  values[, var.name.col] <- var.name.values #
#
  # Retrieving the right coefficients#
  beta0 <- chopit.results$coef$beta0#
  beta <- c(0, chopit.results$coef$beta0)#
  gamma <- chopit.results$coef$gamma#
  kK <- chopit.results$constants$kK#
#
  # Calculating the tau for each row of values#
  tau0 <- values %*% gamma[, 1, drop = FALSE]#
  if (kK >1) { #
    for (k in 2:(kK - 1)) tau0 <- cbind(tau0, tau0[, ncol(tau0), drop = FALSE] + exp(values %*% #
    gamma[, k, drop = FALSE]))#
  }#
  # Calculating the through-y.star.s variable's partial impact on P(y.s >= response) for each row in values#
  latent.partial <- beta[var.name.col] * dnorm(values %*% t(t(beta)) - tau0[, response - 1])#
  # Calculating the through-tau variables partial impact on P(y.s >= response) for each row in values#
  #   First, calculating deriv_tau.rm1, a row vector of which row i contains the marginal variations in tau_{response - 1} for row i of values#
  if (response == 2) deriv.tau.rm1 <- seq(from = gamma[var.name.col, 1], to = gamma[var.name.col, 1], length.out = kNPoints)#
  if (response > 2) {#
  	for (i in (response - 1):(2)) {#
  	  deriv.tau.rm1 <- gamma[var.name.col, i] * exp(values %*% gamma[, i, drop = FALSE])#
  	  }#
  	  deriv.tau.rm1 <- deriv.tau.rm1 + gamma[var.name.col, 1]#
  }#
  #   Then, obtain the row of throug-tau contributions to the partial impact#
  tau.partial <- - deriv.tau.rm1 * dnorm(values %*% beta - tau0[, response - 1])#
  # Eventually, calculating the vector of partial effects of variable var.name on the probability#
  partial <- latent.partial + tau.partial#
  return(list(var.name.col, x.average, var.name.values, values, tau, latent.partial.marginal, deriv.tau.rm1, tau.partial, latent.partial))#
}
ChopitMarginal(chopit.pain, "age", 3, 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 3, 10)
ChopitMarginal(chopit.pain, "age", 2, 10)
summary(chopit.pain)
ChopitMarginal(chopit.pain, "age", 4, 10)
ChopitMarginal(chopit.pain, "age", 5, 10)
ChopitMarginal(chopit.pain, "age", 6, 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitMarginal.R")
ChopitMarginal(chopit.pain, "age", 6, 10)
ChopitMarginal(chopit.pain, "age", 5, 10)
ChopitMarginal(chopit.pain, "age", 4, 10)
ChopitMarginal(chopit.pain, "age", 3, 10)
ChopitMarginal(chopit.pain, "age", 2, 10)
ChopitMarginal(chopit.pain, "age", 6, 10)
ChopitMarginal(chopit.pain, "age", 5, 10)
summary(chopit.pain)
ChopitMarginal(chopit.pain, "age", 4, 10)
ChopitMarginal(chopit.pain, "age", 5, 10)
summary(chopit.pain)
library(foreign) #library translating dta -> R dataset#
library(rgrs)#
library(anchors)#
library(MASS)#
#
if (Sys.info()["sysname"] == "Darwin" & Sys.info()["user"] == "xavier") {#
  chopit.routines.directory = "~/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "PSE\\x.fontaine") {#
  chopit.routines.directory = "~/U/Travail/Range_frequency/routines/"#
  share.data.directory = "~/U/Travail/Range_frequency/data/"#
}#
#
source(paste(chopit.routines.directory,"NonparaComparable.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"NonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"SNonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginal.R", sep = ""), chdir = TRUE)#
#
# Data Conversion: dta to Rdata#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_for_R.dta",convert.factors=TRUE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_factors.Rdata")#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE.dta",convert.factors=FALSE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_nofactors.Rdata")#
#
load(paste(share.data.directory,"/merged_SHARE_factors.Rdata", sep = ""))
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <- data.frame(SHARE$country, SHARE$education, SHARE$jobstat)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)
polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "logistic")
polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/1_Recherches/Programmation/essai_para.R")
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  print(head(SHARE.temp))#
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
ChopitForAlternatives <- function(group.data.frame) {#
	group.data.frame <- data.frame(SHARE$country, SHARE$age_tercile, SHARE$education)#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  print(head(SHARE.temp))#
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <- data.frame(SHARE$country, SHARE$education, SHARE$jobstat)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)
+ median.group.lnPChhincome, data = SHARE.temp, method = "probit")
test.polr$na.action
test.polr$method
names(test.polr)
polr$lev
test.polr$lev
test.polr$call
test.polr$model
names(test.polr)
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
?cbind
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitStartingValues.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  print(head(SHARE.temp))#
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitStartingValues.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
test.polr
summary(test.polr)
length(test.polr$fitted.values)
lengh(test.polr$coefficients)
length(test.polr$coefficients)
test.polr$coefficients
warning()
warnings()
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/ChopitStartingValues.R")
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
source("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//RtmpXd8aNg/filebc33758c30c")#
unlink("/var/folders/ml/f3xz4gl107115l62tmbr56fr0000gn/T//RtmpXd8aNg/filebc33758c30c")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
length(test.polr$coefficients)
(test.polr$coefficients)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
2°) Chopit - with nominal income per capita#
f <- list(self = v1 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(wave) + factor(country),#
           vign = cbind(v8) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(wave) + factor(country))
chopit.pain <- Chopit(formula = f, data = SHARE, naive = FALSE, varcov.method = "OPG")
summary(chopit.pain)
head(test.polr$model)
?aggregate
?eve
?ave
test.polr
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
test.polr
head(test.polr$model)
test.inv <- inv(test.polr$model[, -1] %*% t(test.polr$model[, -1]))
test.inv <- solve(test.polr$model[, -1] %*% t(test.polr$model[, -1]))
length(ncol(test.polr$model))
(ncol(test.polr$model))
ncol(test.polr$model)
typeof(test.polr$model)
names(test.polr$model)
ncol(test.polr$model$x.s[, -1])
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
ALTERNATIVE SPECIFICATIONS#
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
#
group.specifications <- list(data.frame(SHARE$country, SHARE$education, SHARE$jobstat), #
                             data.frame(SHARE$country, SHARE$education, SHARE$gender),#
                             data.frame(SHARE$country, SHARE$age_tercile, income.tercile),#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
)#
#
ChopitForAlternatives <- function(group.data.frame) {#
  median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
  SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
  f <- list(self = v39 ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome,#
           vign = cbind(v43, v44) ~ 1,    #
           tau = ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country)#
                   + median.group.lnPChhincome) #
  chopit.income.sat.comp <- Chopit(formula = f, data = SHARE.temp, naive = FALSE, varcov.method = "OPG")#
  return( chopit.income.sat.comp)#
}#
#
chopit.income.sat.ref.alternatives <- lapply(group.specifications, ChopitForAlternatives)
chopit.income.sat.ref.alternatives
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <- data.frame(SHARE$country, SHARE$education, SHARE$jobstat)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
test.polr
length(test.polr$coefficients)
names(chopit.income.sat.ref.alternatives[[1]]) %*% in
names(chopit.income.sat.ref.alternatives[[1]])
names(chopit.income.sat.ref.alternatives[[1]]$coefficients)
names(chopit.income.sat.ref.alternatives[[1]]$coefficients) %in% names(chopit.income.sat.ref.alternatives[[2]]$coefficients)
names(chopit.income.sat.ref.alternatives[[1]]$coefficients)
c(names(chopit.income.sat.ref.alternatives[[1]]$coefficients))
table(SHARE$v39, SHARE$country)
names(chopit.income.sat.ref.alternatives[[1]]$coefficients) %in% names(chopit.income.sat.ref.alternatives[[4]]$coefficients)
c(names(chopit.income.sat.ref.alternatives[[1]]$coefficients))
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
                             data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <-                              data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <- data.frame(SHARE$country, SHARE$education, SHARE$gender)#
# group.data.frame <- data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       , data = SHARE.temp, method = "probit")
?glm.fit
TACLKING MULTI-CO#
#####################
income.tercile <- findInterval(x = SHARE$lnPChhincome, quantile(SHARE$lnPChhincome, probs = c(1/3, 2/3), na.rm = TRUE))#
group.data.frame <- data.frame(SHARE$country, SHARE$education, SHARE$gender)#
# group.data.frame <- data.frame(SHARE$country, SHARE$age_tercile, SHARE$gender)#
median.group.lnPChhincome <- ave(SHARE$lnPChhincome, group.data.frame, FUN = median)#
SHARE.temp <- data.frame(SHARE, median.group.lnPChhincome = median.group.lnPChhincome)#
#
test.polr <- polr(as.factor(v39) ~ lnPChhincome +  age + numchildren + factor(gender) + factor(education) + factor(jobstat) + factor(country) #
                       + median.group.lnPChhincome, data = SHARE.temp, method = "probit")
test.polr$coefficients
test.polr$zeta
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/Chopit.R")
library(foreign) #library translating dta -> R dataset#
library(rgrs)#
library(anchors)#
library(MASS)#
#
if (Sys.info()["sysname"] == "Darwin" & Sys.info()["user"] == "xavier") {#
  chopit.routines.directory = "~/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "x.fontaine") {#
  chopit.routines.directory = "~/U/Travail/Range_frequency/routines/"#
  share.data.directory = "~/U/Travail/Range_frequency/data/"#
}#
#
source(paste(chopit.routines.directory,"NonparaComparable.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"NonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"SNonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"GroupAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginal.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginalThresholds.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisMean.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisVar.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"OriginalData.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"BootIndividualAnalysis.R", sep = ""), chdir = TRUE)#
#
# Data Conversion: dta to Rdata#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_for_R.dta",convert.factors=TRUE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_factors.Rdata")#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE.dta",convert.factors=FALSE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_nofactors.Rdata")#
#
load(paste(share.data.directory,"/merged_SHARE_factors.Rdata", sep = ""))#
####################
# GLOBAL CONSTANTS#
####################
B <- 200#
ncpus <- 12#
#
####################
# DATA PREPARATION#
####################
SHARE <- SHARE[, c("mergeid", "wave", #
                  "hhincome", "PChhincome", "lnhhincome", "lnPChhincome", "hhincome_r", "PChhincome_r", "lnhhincome_r", "lnPChhincome_r",#
                  "hhsize", "numchildren", "gender", "age", "education", "jobstat", "country", "age_median", "age_tercile",#
                  paste("v",1:64, sep = "")[paste("v",1:64, sep = "") %in% names(SHARE)])]#
SHARE <- droplevels(SHARE)  # Dropping unused levels that come from the fact the actual SHARE is a subset of the whole SHARE. This avoids problems#
                            # when using factors in formula (since a dummy is created for all the levels)
Generating data#
#
############
# CONSTANTS#
############
# Scalars#
kN <- 1e+3#
heterosk <- TRUE#
kK <- 4  # This parameter is not meant to be played around with#
kV <- 2  # This parameter is not meant to be played around with#
#
# Coefficients#
beta <- rbind(0, 1.5, 2)#
gamma <- cbind(c(-1.5, 0.5, 1),c(1, .05, .05),c(.6, .05, .05)) # gamma = (gamma.1, gamma.2, gamma.3)#
theta <- cbind(3, 4)#
kappa <- rbind(0, 0.5, -0.5)#
sigma.v1 <- 1#
sigma.v2 <- 1.3#
sigma.v <- cbind(sigma.v1, sigma.v2)#
sigma.tilde.v <- log(1 / sigma.v)#
#
############
# VARIABLES#
############
# Generating the xs#
x <- cbind(replicate(kN, 1), replicate(2, rnorm(kN, mean = 1, sd = 2), 2))#
names(x) <- c("const", "x1", "x2")#
#
# Generating the sigma.s#
sigma <- heterosk * exp(x %*% kappa) + (1-heterosk) * replicate(kN, 1)#
#
# Generating the tau#
tau.0 <- matrix(-Inf, nrow = kN) ; tau.4 <- matrix(+Inf, nrow = kN)#
tau.1 <- x %*% gamma[, 1, drop = FALSE]#
tau.2 <- tau.1 + exp(x %*% gamma[, 2, drop = FALSE])#
tau.3 <- tau.2 + exp(x %*% gamma[, 3, drop = FALSE])#
tau <- cbind(tau.0, tau.1, tau.2, tau.3, tau.4)#
#
# Generating the self-assessment variable#
epsilon.s <- rnorm(kN)#
y.star.s <- x %*% beta + sigma * epsilon.s#
y.s <- matrix(0, nrow = kN)#
for (k in 1:kK) {#
  y.s <- y.s + k * (tau[, k] <= y.star.s & y.star.s < tau[, k+1])#
}#
#
# Generating the vignette-asessment variables#
epsilon.v1 <- rnorm(kN) ; epsilon.v2 <- rnorm(kN)#
y.star.v1 <- theta[1] + sigma.v1 * epsilon.v1#
y.star.v2 <- theta[2] + sigma.v2 * epsilon.v2#
y.v1 <- matrix(0, nrow = kN)#
y.v2 <- matrix(0, nrow = kN)#
for (k in 1:kK) {#
  y.v1 <- y.v1 + k * (tau[, k] <= y.star.v1 & y.star.v1 < tau[, k+1])#
  y.v2 <- y.v2 + k * (tau[, k] <= y.star.v2 & y.star.v2 < tau[, k+1])#
}#
#
y.v <- cbind(y.v1, y.v2)#
#
# Generating a grouping variable creating two groups in the population ; the first group has higher meann lower variance#
group <- 1 * (x[, 2] < quantile(x[, 2], probs = .30) | x[, 2] > quantile(x[, 2], probs = .95))#
group2 <- rbinom(kN,1,0.5)#
#
# Validating the generated data#
table(y.s)#
table(y.v1)#
table(y.v2)#
tapply(y.star.s, group, mean)#
tapply(y.star.s, group, var)
data <- data.frame(y.s = y.s, y.v1 = y.v1, y.v2 = y.v2, x1 = x[, 2], x2 = x[, 3])#
f <- list(self = y.s ~ x1 + x2,#
          tau = ~ x1 + x2,#
          vign = cbind(y.v1, y.v2) ~ 1,#
          sigma = ~ x1 + x2)#
chopit.simu.heterosk <- Chopit(formula = f, data = data, naive = TRUE, varcov.method = "OPG", heterosk = TRUE)#
boot.simu.heterosk <- BootIndividualAnalysis(chopit.simu.heterosk, B = B, parallel = "no", ncpus = ncpus)
library(foreign) #library translating dta -> R dataset#
library(rgrs)#
library(anchors)#
library(MASS)#
#
if (Sys.info()["sysname"] == "Darwin" & Sys.info()["user"] == "xavier") {#
  chopit.routines.directory = "~/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "x.fontaine") {#
  chopit.routines.directory = "~/U/Travail/Range_frequency/routines/"#
  share.data.directory = "~/U/Travail/Range_frequency/data/"#
}#
#
source(paste(chopit.routines.directory,"NonparaComparable.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"NonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"SNonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"GroupAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginal.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginalThresholds.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisMean.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisVar.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"OriginalData.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"BootIndividualAnalysis.R", sep = ""), chdir = TRUE)#
#
# Data Conversion: dta to Rdata#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_for_R.dta",convert.factors=TRUE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_factors.Rdata")#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE.dta",convert.factors=FALSE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_nofactors.Rdata")#
#
load(paste(share.data.directory,"/merged_SHARE_factors.Rdata", sep = ""))#
####################
# GLOBAL CONSTANTS#
####################
B <- 200#
ncpus <- 12#
#
####################
# DATA PREPARATION#
####################
SHARE <- SHARE[, c("mergeid", "wave", #
                  "hhincome", "PChhincome", "lnhhincome", "lnPChhincome", "hhincome_r", "PChhincome_r", "lnhhincome_r", "lnPChhincome_r",#
                  "hhsize", "numchildren", "gender", "age", "education", "jobstat", "country", "age_median", "age_tercile",#
                  paste("v",1:64, sep = "")[paste("v",1:64, sep = "") %in% names(SHARE)])]#
SHARE <- droplevels(SHARE)  # Dropping unused levels that come from the fact the actual SHARE is a subset of the whole SHARE. This avoids problems#
                            # when using factors in formula (since a dummy is created for all the levels)#
##################
# SIMULATED DATA#
##################
# Analysis on simulated data#
data <- data.frame(y.s = y.s, y.v1 = y.v1, y.v2 = y.v2, x1 = x[, 2], x2 = x[, 3])#
f <- list(self = y.s ~ x1 + x2,#
          tau = ~ x1 + x2,#
          vign = cbind(y.v1, y.v2) ~ 1)#
chopit.simu <- Chopit(formula = f, data = data, naive = FALSE, varcov.method = "OPG")#
chopit.simu$time.elapsed
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/likelihood.R")
?save.image
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
Generating data#
#
############
# CONSTANTS#
############
# Scalars#
kN <- 1e+3#
heterosk <- TRUE#
kK <- 4  # This parameter is not meant to be played around with#
kV <- 2  # This parameter is not meant to be played around with#
#
# Coefficients#
beta <- rbind(0, 1.5, 2)#
gamma <- cbind(c(-1.5, 0.5, 1),c(1, .05, .05),c(.6, .05, .05)) # gamma = (gamma.1, gamma.2, gamma.3)#
theta <- cbind(3, 4)#
kappa <- rbind(0, 0.5, -0.5)#
sigma.v1 <- 1#
sigma.v2 <- 1.3#
sigma.v <- cbind(sigma.v1, sigma.v2)#
sigma.tilde.v <- log(1 / sigma.v)#
#
############
# VARIABLES#
############
# Generating the xs#
x <- cbind(replicate(kN, 1), replicate(2, rnorm(kN, mean = 1, sd = 2), 2))#
names(x) <- c("const", "x1", "x2")#
#
# Generating the sigma.s#
sigma <- heterosk * exp(x %*% kappa) + (1-heterosk) * replicate(kN, 1)#
#
# Generating the tau#
tau.0 <- matrix(-Inf, nrow = kN) ; tau.4 <- matrix(+Inf, nrow = kN)#
tau.1 <- x %*% gamma[, 1, drop = FALSE]#
tau.2 <- tau.1 + exp(x %*% gamma[, 2, drop = FALSE])#
tau.3 <- tau.2 + exp(x %*% gamma[, 3, drop = FALSE])#
tau <- cbind(tau.0, tau.1, tau.2, tau.3, tau.4)#
#
# Generating the self-assessment variable#
epsilon.s <- rnorm(kN)#
y.star.s <- x %*% beta + sigma * epsilon.s#
y.s <- matrix(0, nrow = kN)#
for (k in 1:kK) {#
  y.s <- y.s + k * (tau[, k] <= y.star.s & y.star.s < tau[, k+1])#
}#
#
# Generating the vignette-asessment variables#
epsilon.v1 <- rnorm(kN) ; epsilon.v2 <- rnorm(kN)#
y.star.v1 <- theta[1] + sigma.v1 * epsilon.v1#
y.star.v2 <- theta[2] + sigma.v2 * epsilon.v2#
y.v1 <- matrix(0, nrow = kN)#
y.v2 <- matrix(0, nrow = kN)#
for (k in 1:kK) {#
  y.v1 <- y.v1 + k * (tau[, k] <= y.star.v1 & y.star.v1 < tau[, k+1])#
  y.v2 <- y.v2 + k * (tau[, k] <= y.star.v2 & y.star.v2 < tau[, k+1])#
}#
#
y.v <- cbind(y.v1, y.v2)#
#
# Generating a grouping variable creating two groups in the population ; the first group has higher meann lower variance#
group <- 1 * (x[, 2] < quantile(x[, 2], probs = .30) | x[, 2] > quantile(x[, 2], probs = .95))#
group2 <- rbinom(kN,1,0.5)#
#
# Validating the generated data#
table(y.s)#
table(y.v1)#
table(y.v2)#
tapply(y.star.s, group, mean)#
tapply(y.star.s, group, var)
library(foreign) #library translating dta -> R dataset#
library(rgrs)#
library(anchors)#
library(MASS)#
#
if (Sys.info()["sysname"] == "Darwin" & Sys.info()["user"] == "xavier") {#
  chopit.routines.directory = "~/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "x.fontaine") {#
  chopit.routines.directory = "~/U/Travail/Range_frequency/routines/"#
  share.data.directory = "~/U/Travail/Range_frequency/data/"#
}#
#
source(paste(chopit.routines.directory,"NonparaComparable.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"NonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"SNonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"GroupAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginal.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginalThresholds.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisMean.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisVar.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"OriginalData.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"BootIndividualAnalysis.R", sep = ""), chdir = TRUE)#
#
# Data Conversion: dta to Rdata#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_for_R.dta",convert.factors=TRUE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_factors.Rdata")#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE.dta",convert.factors=FALSE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_nofactors.Rdata")
data <- data.frame(y.s = y.s, y.v1 = y.v1, y.v2 = y.v2, x1 = x[, 2], x2 = x[, 3])#
f <- list(self = y.s ~ x1 + x2,#
          tau = ~ x1 + x2,#
          vign = cbind(y.v1, y.v2) ~ 1,#
          sigma = ~ x1 + x2)
boot.simu.heterosk <- BootIndividualAnalysis(data = SHARE, formula = f, heterosk = TRUE, B = B, parallel = "no", ncpus = 1)
boot.simu.heterosk <- BootIndividualAnalysis(data = data, formula = f, heterosk = TRUE, B = B, parallel = "no", ncpus = 1)
GLOBAL CONSTANTS#
####################
B <- 200#
ncpus <- 12
boot.simu.heterosk <- BootIndividualAnalysis(data = data, formula = f, heterosk = TRUE, B = 2, parallel = "no", ncpus = 1)
summary(chopit.pain.heterosk)
nrow(SHARE)
ls
?multicore
library(parallel)
?multicore
??multicore
?snow
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
character(0) + 'a'
character(0) 'a'
character(0) & 'a'
c(character(0), 'a')
'a'  + 'a'
'a' 'a'
b <- character(10)
b <- B * 'a'
b <- b * 'a'
rep('a')
rep('a', n = 10)
rep('a', times = 10)
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
?rep
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
kK <- 5
rep("BootIteration: error on this iteration", times = 3 * kK + 3 * (kK - 1))
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
?cat
source("/Users/xavier/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/BootIndividualAnalysis.R")
.3^2
.7^2
.4
.4^2
6 *22 + 3
library(foreign) #library translating dta -> R dataset#
library(rgrs)#
# library(anchors)#
library(MASS)#
library(xtable)#
#
if (Sys.info()["sysname"] == "Darwin" & Sys.info()["user"] == "xavier") {#
  chopit.routines.directory = "~/Documents/Travail/Boulot Fac/Doctorat/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "x.fontaine") {#
  chopit.routines.directory = "~/U/Travail/Range_frequency/routines/"#
  share.data.directory = "~/U/Travail/Range_frequency/data/"#
}#
#
if (Sys.info()["sysname"] == "Linux" & Sys.info()["user"] == "kamixave") {#
  chopit.routines.directory = "~/Dropbox/0_Boulot_portatif/1_ Productions personnelles/24_Range-Frequency/2_programmes/"#
  share.data.directory = "~/Documents/Travail/Databases/SHARE/"#
}#
#
source(paste(chopit.routines.directory,"NonparaComparable.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"NonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"SNonparaAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"Chopit.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"GroupAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginal.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"ChopitMarginalThresholds.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisMean.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"IndividualAnalysisVar.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"OriginalData.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"BootIndividualAnalysis.R", sep = ""), chdir = TRUE)#
source(paste(chopit.routines.directory,"AttenuationAnalysis.R", sep = ""), chdir = TRUE)#
#
# Data Conversion: dta to Rdata#
# SHARE <- read.dta("~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_for_R.dta",convert.factors=TRUE)#
# save(SHARE,file="~/Documents/Travail/Boulot Fac/Doctorat/Data bases/SHARE/0_merged_data/merged_SHARE_factors.Rdata")
summary(chopit.breath.heterosk)
summary(chopit.breath.heterosk)$table
nrow(summary(chopit.breath.heterosk)$table)
6 *22 + 3 * 2
6 *22 + 3 + 3 * 2
6 *22 + 4 + 3 * 2
nrow(summary(chopit.work.dsbility.heterosk)$table)
